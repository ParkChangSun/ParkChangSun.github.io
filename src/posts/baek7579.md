---
title: Beakjoon 7579 - 앱
date: 2025-10-20
---

# Beakjoon 7579 - 앱

[Link](https://www.acmicpc.net/problem/7579)

## 입력

- 앱 개수 $1 \leq N \leq 100$
- 필요한 메모리 $1 \leq M \leq 10,000,000$
- 앱 `App{memory m, cost c int}`
- $1 \leq m_1, \ldots , m_N \leq 10,000,000$
- $M \leq m_1 + \ldots + m_N$
- $0 \leq c_1 , \ldots , c_N \leq 100$

## 문제

필요한 메모리 M 을 확보하기 위한 앱 비활성화의 최소의 비용

## 풀이

계산에 포함한 앱 개수가 n 일 때, 확보한 메모리를 m, 발생한 비용을 c 라 하자.

직관적으로 메모리 M을 확보했을 때 최소 비용을 구하는 식은 다음과 같다.

$DP(m)=min(DP(m),DP(m-A.m)+A.c)$

하지만 m 바이트 이상을 확보해도 메모리 m 을 확보한다는 조건이 성립하므로, `k >= m` 인 k 값들을 전부 고려해야 한다. 이는 메모리 m을 확보했을 때 최소 비용이라는 정의와는 조금 어색하다.

공간복잡도는 $O(M)$
시간복잡도는 100*10,000,000 $O(NM^2)$? 아마도

이론적으로 불가능한 풀이는 아니지만 시간 공간 복잡도도 크고 풀이 방향에도 맞지 않는다. 이 풀이가 아니라면 상태를 표현하는 축을 바꿔 보자.

어떤 비용을 사용해 확보할 수 있는 최대 메모리를 구하는 식은 다음과 같다.

$DP(c)=max(DP(c),DP(c-A.c)+A.m)$

이 풀이는 비용이 무게이고, 메모리가 가치인 배낭 문제가 된다. 최대 무게가 비용의 합이고 가치가 M 이상인 무게의 최소값을 찾는 과정이 추가로 필요할 뿐이다.

직관적으로 첫 번째 풀이를 떠올렸을 때 그 풀이가 아니라면, dp축을 바꿔 보는 사고가 필요하다.

## 코드

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

var std = bufio.NewReadWriter(bufio.NewReader(os.Stdin), bufio.NewWriter(os.Stdout))

func main() {
	defer std.Flush()

	var n, m int
	fmt.Fscan(std, &n, &m)
	mem := make([]int, n)
	cost := make([]int, n)
	csum := 0
	for i := range n {
		fmt.Fscan(std, &mem[i])
	}
	for i := range n {
		fmt.Fscan(std, &cost[i])
		csum += cost[i]
	}

	dp := make([]int, csum+1)

	for i := range n {
		for c := csum; c >= cost[i]; c-- {
			dp[c] = max(dp[c-cost[i]]+mem[i], dp[c])
		}
	}

	for i, v := range dp {
		if v >= m {
			fmt.Fprintln(std, i)
			break
		}
	}
}
```