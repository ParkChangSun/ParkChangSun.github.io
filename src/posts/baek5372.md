---
title: Baekjoon 5372 - 나쁜 과학자
post_date: 2025-10-25
edit_date: 2025-10-25
keywords: 백트래킹 백준 5372 나쁜 과학자
description: 백트래킹 문제입니다.
---

# Baekjoon 5372 - 나쁜 과학자

[Link](https://www.acmicpc.net/problem/5372)

# 문제

그래프에서 모든 엣지를 제거하기 위해 제거해야 하는 최소 노드 개수

# 입력

- 노드 수 $1 \leq n \leq 50$
- 제거할 수 있는 최대 노드 수 $0 \leq k \leq 16$
- 엣지 수 $0 ≤ m ≤ n×(n-1)/2$
- 엣지 $1 \leq x_i \lt y_i \leq n$

# 풀이

어떤 노드에 연결된 엣지 수에 따라 경우를 나눌 수 있다.

모든 엣지를 제거하려면 엣지에 연결되어 있는 두 노드들 중 하나는 반드시 제거되어야 한다.

그래프 상의 노드들 중 엣지와 연결되어 있지 않은 노드들은 고려할 필요가 없다.

어떤 노드가 하나의 엣지로만 연결되어 있다면 그 엣지 또는 다른 엣지는 제거되어야 한다. 그러나 반대의 엣지가 1개 이상의 엣지에 연결되어 있을 수도 있으니 반대 엣지를 제거한다.

위 두 경우는 선택할 수 있는 경우가 하나밖에 없기 때문에 백트래킹할 필요가 없다.

어떤 노드가 두 개 이상의 엣지에 연결되어 있다면 엣지 중 하나를 잡고 두 노드중 하나를 제거하는 백트래킹한다.

백트래킹 중 노드를 제거할 때마다 k 값을 1씩 감소한다. 더이상 제거할 엣지가 없거나 k가 0밑으로 떨어지면 백트래킹을 종료한다.

노드 수가 50 이하이므로 비트마스킹을 통해 지워야 할 노드들과 엣지들을 표현할 수 있다.

비트마스킹에 도움이 되는 `math/bits` 패키지를 이제야 알았다. 앞으로 유용하게 쓸 것 같다.

추가로 최적화한 부분은 어떤 노드에 연결된 엣지 수보다 k가 작으면 백트래킹을 종료하는 것이 있다.

# 코드

```go
package main

import (
	"bufio"
	"fmt"
	"math/bits"
	"os"
)

var std = bufio.NewReadWriter(bufio.NewReader(os.Stdin), bufio.NewWriter(os.Stdout))

var n, k, m int
var min int

var graph []uint64

func main() {
	defer std.Flush()

	var cases int
	fmt.Fscan(std, &cases)
	for i := 0; i < cases; i++ {
		fmt.Fscan(std, &n, &k, &m)

		min = 51
		graph = make([]uint64, n+1)

		for j := 0; j < m; j++ {
			a, b := 0, 0
			fmt.Fscan(std, &a, &b)
			graph[a] = graph[a] | (1 << b)
			graph[b] = graph[b] | (1 << a)
		}

		backtrack(uint64(1<<(n+1)-2), k)

		if min == 51 {
			fmt.Fprintln(std, "IMPOSSIBLE")
		} else {
			fmt.Fprintln(std, min)
		}
	}
}

func backtrack(alive uint64, kleft int) {
	for change := true; change; {
		change = false

		for i := 1; i <= n; i++ {
			if alive&(1<<i) == 0 {
				continue
			}

			edges := bits.OnesCount64(alive & graph[i])

			if edges == 0 {
				alive -= 1 << i
			} else if edges == 1 {
				alive -= 1 << i
				alive -= 1 << bits.TrailingZeros64(alive&graph[i])
				kleft--
				change = true
			} else if edges > kleft {
				alive -= 1 << i
				kleft--
				change = true
			}
		}
	}

	if alive == 0 {
		if kleft >= 0 && k-kleft < min {
			min = k - kleft
		}
		return
	}
	if kleft <= 0 {
		return
	}

	p := bits.TrailingZeros64(alive)
	t := bits.TrailingZeros64(alive & graph[p])

	backtrack(alive-(1<<p), kleft-1)
	backtrack(alive-(1<<t), kleft-1)
}
```