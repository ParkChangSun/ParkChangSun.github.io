---
title: Beakjoon 7579 - 앱
date: 2025-10-20
---

# Beakjoon 7579 - 앱

[Link](https://www.acmicpc.net/problem/7579)

## 입력

- 앱 개수 N
- 필요한 메모리 M
- `App{memory m, cost c int}`
- $1 \leq N \leq 100$
- $1 \leq M \leq 10,000,000$
- $1 \leq m_1, \ldots , m_N \leq 10,000,000$
- $M \leq m_1 + \ldots + m_N$
- $0 \leq c_1 , \ldots , c_N \leq 100$

## 문제

필요한 메모리 M 을 확보하기 위한 앱 비활성화의 최소의 비용

## 풀이

상태 정의
계산에 포함한 앱 개수 n
확보한 메모리 m
비용 c

상태를 메모리 m을 확보하는 데 필요한 최소 비용 c로 하면
M leq sum m 이 가능하기 때문에 최대 공간이 1000000000
dp[m] = m바이트 확보를 위한 최소 비용 으로 두면

$DP[m]=min(DP[m],DP[m-A.m]+A.c)$

하지만 m바이트 이상을 확보해도 문제의 조건이 성립한다. 따라서 m geq M 범위의 값들을 전부 고려해야 한다.

불가능한 풀이는 아니지만 시간 공간 복잡도도 크고 풀이 방향에도 맞지 않는다.

상태를 비용 c에서 확보가능한 최대 메모리로 하면

$DP(c)=max(DP(c),DP(c-A.c)+A.m)$

이렇게 하면 m 이 M 이상인 비용 최소값을 찾을 수 있다.

직관적으로 첫 번째 풀이를 떠올릴 수 있는데 시간 공간 복잡도가 크니 dp축을 바꿔 보는 사고가 필요하다.

## 코드

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

var std = bufio.NewReadWriter(bufio.NewReader(os.Stdin), bufio.NewWriter(os.Stdout))

func main() {
	defer std.Flush()

	var n, m int
	fmt.Fscan(std, &n, &m)
	mem := make([]int, n)
	cost := make([]int, n)
	csum := 0
	for i := range n {
		fmt.Fscan(std, &mem[i])
	}
	for i := range n {
		fmt.Fscan(std, &cost[i])
		csum += cost[i]
	}

	dp := make([]int, csum+1)

	for i := range n {
		for c := csum; c >= cost[i]; c-- {
			dp[c] = max(dp[c-cost[i]]+mem[i], dp[c])
		}
	}

	for i, v := range dp {
		if v >= m {
			fmt.Fprintln(std, i)
			break
		}
	}
}
```